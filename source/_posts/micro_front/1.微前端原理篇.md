---
title: 微前端原理篇
date: 2022-04-12 20:19:36
updated:
tags:
- 架构
- 微前端
  
categories:
- [架构, 微前端]
  
---

微前端是当下比较热门的技术架构，在面试过程中被问起的频次很高，本篇将详细探索微前端的应用及原理。

### 什么是微前端

微前端起源于微服务的思想，将微服务的思想应用在浏览器端，其核心是将 web 端的单一应用分解成一个主应用+多个子应用的结构，各个子应用独立运行，独立开发，独立部署，代码和业务层面相互解耦。

### 微前端兴起的原因

微前端最早在 2016 年底被提出，那段时间正好是单页面应用横行的时候，三大框架（`React`、`Vue`、`Angular`）如日中天，但随着时间推进，这些单页面应用体积越来越大，构建时间变得越来越慢，性能也越来越差，想拆分或者重构也无从下手；做了新系统之后想要兼容老系统，只能通过 iframe 的方式嵌入，产生隔离感；跨团队的项目可能因为技术栈的不统一，需要增加学习成本或者干脆被放弃；微前端的出现正是为了解决这些问题。

- **应用拆分**：我们可以根据自己的业务特点，将公共部分如左侧菜单、顶部工具栏等拆分到主应用，具体业务实现根据其业务条线换分到不同子应用中，对整个系统进行解耦。这样，首先来说可以将巨石应用进行分解，将一个应用变成多个应用，减少了每个应用的体积，相应的就会带来效率上的提升；其次，如果增加新业务线也可以通过增加新的子应用的方式来增加，无需侵入之前的业务，对之前的项目升级也可以单独升级其中的一个子应用，从而降低对整体的影响。

- **技术栈无关**：根据微前端的特点，各个子应用都是一个独立的应用，我们可以对这些子应用使用不同的技术框架，无论你是 `React` 还是 `Vue`，都可以独立运行在微前端框架下，当然你还得保证你整个应用的风格是一致的，否则会产生很强的割裂感。

### 微前端的技术方案

在介绍微前端的方案之前，先说一下之前经历过的一种架构模型，当时称之为前端微服务。

这种技术架构也是借鉴于微服务的思想，将前端划分成了一个个子应用，但是与现在的微前端的方案不同，这种方式没有主应用，所有的子应用采用相同的架构模型，也就是同一个子应用的 `Copy`。之前采用的技术框架是 `React SSR + BFF层`，共用部分则是采用的 `npm` 包的方式，如左侧菜单，顶部状态栏，路由的分发则依赖于 `nginx` 服务器和 BFF 层，`nginx` 根据域名和一级路由转发到响应的前端微服务，`BFF` 再根据子路由渲染对应的页面。

![前端微服务](前端微服务.png)

这种架构的优点和微前端很像，就是应用的拆分，巨大的业务拆分到几十个项目，业务可以相互解耦。但是也有很明显的缺点：

- 子应用相互隔离。由于本身就是一个完整的系统，不同应用之间相互跳转，会引起页面刷新，导致短暂的白屏；再者子应用之间的相互通信只能通过 url 携带参数的方式传递；再就是无法进行预加载，没法做加载性能的优化。
- 公共内容使用 npm 包管控。使用 npm 包就意味着每次更新都需要发版，发版完成之后所有用的子应用都需要更新，上线之后每次发布都会导致批量更新，需要验证的范围非常大，这个是非常不好的一个点。

所以，这种架构模式在当时算是一个比较折中的方案，虽然能够对业务进行拆分，但是也有着不可回避的问题。微前端的出现，正好弥补了这种架构的缺点。

微前端的方案有很多，有类似上述的暂且能算作微前端的运维服务的转发，还有依赖 `iframe` 实现的方案，依赖 `WebComponent` 的方案，还有基于 SPA 特性的 `single-SPA`。

| 方案           | 描述                                                                                                         | 优点                                                                                                         | 缺点                                                                                                                                                |
| -------------- | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| 运维服务转发   | 依赖于运维服务器对根路由的解析，然后转发到不同的应用中                                                       | 实现比较简单，能够拆解应用                                                                                   | 依赖于运维服务的转发，子应用之间相互跳转会引起浏览器的刷新，体验不好                                                                                |
| `iframe`       | 主应用嵌入 `iframe`，`iframe` 打开子应用                                                                     | `iframe` 作为天然沙箱，各个应用之间相互隔离，互相不影响。主子应用通信依赖于 `contentWindow` 和 `postMessage` | `iframe` 成也因为隔离，败也因为隔离。正是因为隔离效果太强，会让主子应用之间产生割裂感，如弹窗的蒙层，只能覆盖在子应用中，带来的体验也是非常不好的。 |
| `WebComponent` | `WebComponent` 也是浏览器自带的，具有天然隔离效果的一种方案，其 `css` 和 `javascript` 也都是独立部署应用的   | 天然隔离                                                                                                     | 兼容性的问题，再就是子应用需要改写成 `WebComponent` 的写法，改造成本比较高                                                                          |
| `single-SPA`   | 由一个主应用和多个子应用组成，子应用独立部署，主应用负责路由分发，消息传递，应用的加载、卸载、子应用的隔离。 | 纯前端完成，改造便捷，拥有以上几种方案的优点                                                                 | 方案复杂，需要特别关注子应用的隔离，防止样式和 `JavaScript` 变量的污染                                                                              |

### 微前端的实际应用

详细请看 微前端实践篇

### 微前端的核心原理

微前端实现中有几个比较核心的部分：路由分发（应用注册、路由劫持、生命周期）、应用隔离（JS 沙箱、CSS 样式隔离）、全局通信，下面将以 `qiankun` 为例，从这几个方面展开描述。

#### 应用注册

首先看一下 `qiankun` 中应用如何注册：

```javascript
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#container',
    activeRule: '/react',
    props: {
      name: 'kuitos',
    },
  },
]);
```

大致有这么几个参数：

- `name`：子应用的名称
- `entry`：子应用的入口
- `container`：子应用注册的 `DOM` 节点
- `activeRule`：子应用激活的路由规则
- `loader`：子应用加载状态变化时的回调方法
- `props`：主应用传递给子应用的数据

可以看到这个和我们平时写路由非常相似，`entry` 对应着组件，`activeRule` 对应的路由的 `path`，所以基本可以参考路由的模型，只要在`activeRule` 变化时，加载对应的组件即可。这个比较简单，只要在内存中将 app list 保存起来即可。

#### 路由劫持

注册完成之后，下一步就是如何将子应用渲染出来了。上面也提到了，注册应用时配置了 `activeRule`，如果你看过 `ReactRouter` 或者 `VueRouter`的话，那么很容易想到该怎么做。

单页面应用的路由分为两种：`history` 模式和 `hash` 模式。

- `hash` 模式：路由以#开头，如 `http://localhost:8080/#/example`，这种方式可以通过监听 `hashchange` 的来监听路由是否发生变化，但首次进入页面时不会触发 `hashchange` 事件，这时我们需要搭配 `load` 事件来完成首次进入时的监听。

```javascript
window.addEventListener('hashchange', () => {
  console.log(window.location.hash);
});

window.addEventListener('onload', () => {
  console.log(window.location.hash);
});
```

- `history`模式：路由和我们常见的地址一致，但是 `history` 无法监听，只能通过重写 `history` 的 `replaceStatement` 和 `pushStatement`

```javascript
const originReplace = window.history.replaceStatement;
const originPush = window.history.pushStatement;

window.history.pushStatement = function (...args) {
  // 挂载子应用
  ...
  // 调用原有方法
  originPush.apply(window.history, args)
}

window.history.originReplace = function (...args) {
  // 切换子应用
  ...

  // 调用原有方法
  originReplace.apply(window.history, args)
}
```

其大致原理就是如此，详情可以参考 `VueRouter` 或者 `ReactRouter` 的实现。
